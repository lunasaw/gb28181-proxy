# GB28181-Proxy å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯ä¼˜åŒ–æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è¿°

è¿™æ˜¯ä¸€ä¸ªåŸºäºSIPåè®®çš„GB28181é€šä¿¡æ¡†æ¶ï¼Œé‡‡ç”¨å®¢æˆ·ç«¯/æœåŠ¡ç«¯åˆ†ç¦»æ¶æ„ï¼Œä½¿ç”¨Spring Boot 3.3.1å’ŒJava 17æ„å»ºã€‚é¡¹ç›®æ”¯æŒè®¾å¤‡æ³¨å†Œã€è®¤è¯ã€æ§åˆ¶ã€å‘Šè­¦ç­‰æ ‡å‡†åè®®ä¿¡ä»¤æœåŠ¡ã€‚

## 1. æ€§èƒ½ä¼˜åŒ–

### 1.1 çº¿ç¨‹æ± ä¼˜åŒ–

**å½“å‰é—®é¢˜ï¼š**
- `ThreadPoolTaskConfig`ä¸­çº¿ç¨‹æ± é…ç½®å›ºå®šï¼ˆcorePoolSize=200, maxPoolSize=200ï¼‰
- å¤šä¸ªåœ°æ–¹ä½¿ç”¨`Executors.newScheduledThreadPool(1)`åˆ›å»ºå•çº¿ç¨‹æ± 
- ç¼ºä¹çº¿ç¨‹æ± ç›‘æ§å’ŒåŠ¨æ€è°ƒæ•´æœºåˆ¶

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 1.1.1 ç»Ÿä¸€çº¿ç¨‹æ± ç®¡ç†
```java
@Configuration
public class OptimizedThreadPoolConfig {
    
    @Bean("sipMessageProcessor")
    public ThreadPoolTaskExecutor sipMessageProcessor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 2);
        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 4);
        executor.setQueueCapacity(1000);
        executor.setKeepAliveSeconds(60);
        executor.setThreadNamePrefix("sip-msg-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Bean("sipScheduledExecutor")
    public ScheduledThreadPoolExecutor sipScheduledExecutor() {
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(
            Runtime.getRuntime().availableProcessors(),
            new ThreadFactoryBuilder()
                .setNameFormat("sip-scheduled-%d")
                .setDaemon(true)
                .build()
        );
        return executor;
    }
}
```

#### 1.1.2 å¼‚æ­¥æ¶ˆæ¯å¤„ç†
```java
@Component
public class AsyncSipMessageProcessor {
    
    @Autowired
    @Qualifier("sipMessageProcessor")
    private ThreadPoolTaskExecutor messageExecutor;
    
    @Async("sipMessageProcessor")
    public CompletableFuture<Void> processMessageAsync(RequestEvent requestEvent) {
        // å¼‚æ­¥å¤„ç†æ¶ˆæ¯
        return CompletableFuture.completedFuture(null);
    }
}
```

### 1.2 å†…å­˜ä¼˜åŒ–

**å½“å‰é—®é¢˜ï¼š**
- ä½¿ç”¨å¤šä¸ª`ConcurrentHashMap`å­˜å‚¨è®¾å¤‡ä¿¡æ¯å’Œè®¢é˜…ä¿¡æ¯
- ç¼ºä¹å†…å­˜æ¸…ç†æœºåˆ¶
- æ— æ³•æ§åˆ¶ç¼“å­˜å¤§å°

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 1.2.1 å¼•å…¥Caffeineç¼“å­˜
```xml
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>3.1.8</version>
</dependency>
```

#### 1.2.2 ç¼“å­˜ç®¡ç†å™¨
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .expireAfterAccess(Duration.ofMinutes(15))
            .recordStats());
        return cacheManager;
    }
}

@Service
public class OptimizedDeviceManager {
    
    @Cacheable(value = "devices", key = "#deviceId")
    public Device getDevice(String deviceId) {
        // è·å–è®¾å¤‡ä¿¡æ¯
        return null;
    }
    
    @CacheEvict(value = "devices", key = "#deviceId")
    public void removeDevice(String deviceId) {
        // ç§»é™¤è®¾å¤‡
    }
}
```

### 1.3 ç½‘ç»œI/Oä¼˜åŒ–

**å½“å‰é—®é¢˜ï¼š**
- SIPåè®®åŒæ—¶ç›‘å¬TCPå’ŒUDPï¼Œä½†æœªä¼˜åŒ–ç½‘ç»œå‚æ•°
- ç¼ºä¹è¿æ¥æ± ç®¡ç†

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 1.3.1 ä¼˜åŒ–SipLayeré…ç½®
```java
@Component
public class OptimizedSipLayer extends SipLayer {
    
    @Override
    public synchronized void addListeningPoint(String monitorIp, int port, SipListener listener, Boolean enableLog) {
        // ä¼˜åŒ–ç½‘ç»œå‚æ•°
        Properties properties = getOptimizedProperties(monitorIp, enableLog);
        properties.setProperty("gov.nist.javax.sip.TCP_POST_PARSING_THREAD_POOL_SIZE", "64");
        properties.setProperty("gov.nist.javax.sip.THREAD_POOL_SIZE", "64");
        properties.setProperty("gov.nist.javax.sip.REENTRANT_LISTENER", "true");
        
        // åŸæœ‰é€»è¾‘...
    }
    
    private Properties getOptimizedProperties(String monitorIp, Boolean enableLog) {
        Properties properties = DefaultProperties.getProperties("SIP-PROXY", monitorIp, enableLog);
        // æ·»åŠ æ€§èƒ½ä¼˜åŒ–å‚æ•°
        properties.setProperty("gov.nist.javax.sip.MAX_MESSAGE_SIZE", "32768");
        properties.setProperty("gov.nist.javax.sip.TCP_POST_PARSING_THREAD_POOL_SIZE", "64");
        return properties;
    }
}
```

## 2. å®¢æˆ·ç«¯ä¼˜åŒ–

### 2.1 å¿ƒè·³æœºåˆ¶ä¼˜åŒ–

**å½“å‰é—®é¢˜ï¼š**
- å¿ƒè·³é—´éš”å›ºå®šï¼Œæœªè€ƒè™‘ç½‘ç»œçŠ¶å†µ
- ç¼ºä¹æ™ºèƒ½é‡è¿æœºåˆ¶

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 2.1.1 è‡ªé€‚åº”å¿ƒè·³
```java
@Component
public class AdaptiveKeepAliveManager {
    
    private static final AtomicInteger failureCount = new AtomicInteger(0);
    private static final int BASE_INTERVAL = 60; // ç§’
    
    public int calculateKeepAliveInterval() {
        int failures = failureCount.get();
        if (failures == 0) {
            return BASE_INTERVAL;
        } else if (failures < 3) {
            return BASE_INTERVAL / 2; // åŠ å¿«å¿ƒè·³
        } else {
            return Math.min(BASE_INTERVAL * 2, 300); // å‡æ…¢å¿ƒè·³ï¼Œæœ€å¤§5åˆ†é’Ÿ
        }
    }
    
    public void onKeepAliveSuccess() {
        failureCount.set(0);
    }
    
    public void onKeepAliveFailure() {
        failureCount.incrementAndGet();
    }
}
```

### 2.2 æ¶ˆæ¯é˜Ÿåˆ—ä¼˜åŒ–

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 2.2.1 æ¶ˆæ¯é˜Ÿåˆ—ç®¡ç†
```java
@Component
public class MessageQueueManager {
    
    private final BlockingQueue<SipMessage> messageQueue = new LinkedBlockingQueue<>(1000);
    private final AtomicBoolean processing = new AtomicBoolean(false);
    
    @Autowired
    private ThreadPoolTaskExecutor messageExecutor;
    
    public boolean enqueue(SipMessage message) {
        boolean queued = messageQueue.offer(message);
        if (queued) {
            processMessages();
        }
        return queued;
    }
    
    private void processMessages() {
        if (processing.compareAndSet(false, true)) {
            messageExecutor.execute(() -> {
                try {
                    while (!messageQueue.isEmpty()) {
                        SipMessage message = messageQueue.poll();
                        if (message != null) {
                            processMessage(message);
                        }
                    }
                } finally {
                    processing.set(false);
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ¶ˆæ¯è¿›æ¥
                    if (!messageQueue.isEmpty()) {
                        processMessages();
                    }
                }
            });
        }
    }
}
```

## 3. æœåŠ¡ç«¯ä¼˜åŒ–

### 3.1 è®¾å¤‡ç®¡ç†ä¼˜åŒ–

**å½“å‰é—®é¢˜ï¼š**
- è®¾å¤‡çŠ¶æ€ç®¡ç†åˆ†æ•£
- ç¼ºä¹è®¾å¤‡çŠ¶æ€ç›‘æ§

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 3.1.1 è®¾å¤‡çŠ¶æ€ç®¡ç†å™¨
```java
@Component
public class DeviceStateManager {
    
    private final Map<String, DeviceState> deviceStates = new ConcurrentHashMap<>();
    
    @EventListener
    public void handleDeviceRegister(DeviceRegisterEvent event) {
        DeviceState state = new DeviceState();
        state.setStatus(DeviceStatus.ONLINE);
        state.setLastSeen(Instant.now());
        deviceStates.put(event.getDeviceId(), state);
    }
    
    @Scheduled(fixedRate = 30000) // 30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void checkDeviceHealth() {
        Instant threshold = Instant.now().minus(Duration.ofMinutes(5));
        deviceStates.entrySet().removeIf(entry -> {
            if (entry.getValue().getLastSeen().isBefore(threshold)) {
                publishDeviceOfflineEvent(entry.getKey());
                return true;
            }
            return false;
        });
    }
}
```

### 3.2 è´Ÿè½½å‡è¡¡ä¼˜åŒ–

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 3.2.1 æ¶ˆæ¯å¤„ç†è´Ÿè½½å‡è¡¡
```java
@Component
public class LoadBalancedMessageProcessor {
    
    private final List<MessageProcessor> processors;
    private final AtomicInteger roundRobinIndex = new AtomicInteger(0);
    
    public void processMessage(SipMessage message) {
        MessageProcessor processor = selectProcessor();
        processor.process(message);
    }
    
    private MessageProcessor selectProcessor() {
        int index = roundRobinIndex.getAndIncrement() % processors.size();
        return processors.get(index);
    }
}
```

## 4. ç›‘æ§ä¸è¯Šæ–­ä¼˜åŒ–

### 4.1 æ€§èƒ½ç›‘æ§

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 4.1.1 Micrometeré›†æˆ
```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

#### 4.1.2 è‡ªå®šä¹‰æŒ‡æ ‡
```java
@Component
public class SipMetrics {
    
    private final Counter messageProcessedCounter;
    private final Timer messageProcessingTimer;
    private final Gauge activeDevicesGauge;
    
    public SipMetrics(MeterRegistry meterRegistry) {
        this.messageProcessedCounter = Counter.builder("sip.messages.processed")
            .description("Total processed SIP messages")
            .register(meterRegistry);
            
        this.messageProcessingTimer = Timer.builder("sip.message.processing.time")
            .description("SIP message processing time")
            .register(meterRegistry);
            
        this.activeDevicesGauge = Gauge.builder("sip.devices.active")
            .description("Number of active devices")
            .register(meterRegistry, this, SipMetrics::getActiveDeviceCount);
    }
    
    public void recordMessageProcessed() {
        messageProcessedCounter.increment();
    }
    
    public Timer.Sample startTimer() {
        return Timer.start();
    }
}
```

### 4.2 å¥åº·æ£€æŸ¥

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 4.2.1 è‡ªå®šä¹‰å¥åº·æ£€æŸ¥
```java
@Component
public class SipHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DeviceStateManager deviceManager;
    
    @Override
    public Health health() {
        int activeDevices = deviceManager.getActiveDeviceCount();
        
        if (activeDevices > 0) {
            return Health.up()
                .withDetail("activeDevices", activeDevices)
                .withDetail("status", "SIP service is running normally")
                .build();
        } else {
            return Health.down()
                .withDetail("activeDevices", activeDevices)
                .withDetail("status", "No active devices")
                .build();
        }
    }
}
```

## 5. é…ç½®ä¼˜åŒ–

### 5.1 é…ç½®å¤–éƒ¨åŒ–

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 5.1.1 é…ç½®å±æ€§ç±»
```java
@ConfigurationProperties(prefix = "sip.gb28181")
@Data
public class Gb28181Properties {
    
    private Server server = new Server();
    private Client client = new Client();
    private Performance performance = new Performance();
    
    @Data
    public static class Server {
        private String ip = "0.0.0.0";
        private int port = 5060;
        private int maxDevices = 10000;
        private Duration deviceTimeout = Duration.ofMinutes(5);
    }
    
    @Data
    public static class Client {
        private Duration keepAliveInterval = Duration.ofMinutes(1);
        private int maxRetries = 3;
        private Duration retryDelay = Duration.ofSeconds(5);
    }
    
    @Data
    public static class Performance {
        private int messageQueueSize = 1000;
        private int threadPoolSize = 200;
        private boolean enableMetrics = true;
    }
}
```

### 5.2 ç¯å¢ƒé…ç½®

**application.ymlä¼˜åŒ–ï¼š**
```yaml
sip:
  gb28181:
    server:
      ip: ${SIP_SERVER_IP:0.0.0.0}
      port: ${SIP_SERVER_PORT:5060}
      max-devices: ${SIP_MAX_DEVICES:10000}
      device-timeout: ${SIP_DEVICE_TIMEOUT:PT5M}
    client:
      keep-alive-interval: ${SIP_KEEPALIVE_INTERVAL:PT1M}
      max-retries: ${SIP_MAX_RETRIES:3}
      retry-delay: ${SIP_RETRY_DELAY:PT5S}
    performance:
      message-queue-size: ${SIP_MESSAGE_QUEUE_SIZE:1000}
      thread-pool-size: ${SIP_THREAD_POOL_SIZE:200}
      enable-metrics: ${SIP_ENABLE_METRICS:true}

management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

## 6. å®‰å…¨ä¼˜åŒ–

### 6.1 è®¤è¯ä¼˜åŒ–

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 6.1.1 å¢å¼ºçš„æ‘˜è¦è®¤è¯
```java
@Component
public class EnhancedDigestAuthenticationHelper extends DigestServerAuthenticationHelper {
    
    private final RedisTemplate<String, String> redisTemplate;
    private static final String NONCE_PREFIX = "sip:nonce:";
    private static final Duration NONCE_VALIDITY = Duration.ofMinutes(5);
    
    @Override
    public String generateNonce() {
        String nonce = super.generateNonce();
        // å­˜å‚¨nonceåˆ°Redisï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´
        redisTemplate.opsForValue().set(NONCE_PREFIX + nonce, "valid", NONCE_VALIDITY);
        return nonce;
    }
    
    @Override
    public boolean validateNonce(String nonce) {
        String key = NONCE_PREFIX + nonce;
        String value = redisTemplate.opsForValue().get(key);
        if ("valid".equals(value)) {
            // åˆ é™¤å·²ä½¿ç”¨çš„nonceï¼Œé˜²æ­¢é‡æ”¾æ”»å‡»
            redisTemplate.delete(key);
            return true;
        }
        return false;
    }
}
```

## 7. å®æ–½å»ºè®®

### 7.1 åˆ†é˜¶æ®µå®æ–½

1. **ç¬¬ä¸€é˜¶æ®µï¼ˆæ€§èƒ½åŸºç¡€ä¼˜åŒ–ï¼‰**
   - çº¿ç¨‹æ± ä¼˜åŒ–
   - ç¼“å­˜æœºåˆ¶å¼•å…¥
   - åŸºç¡€ç›‘æ§æ·»åŠ 

2. **ç¬¬äºŒé˜¶æ®µï¼ˆé«˜çº§åŠŸèƒ½ä¼˜åŒ–ï¼‰**
   - æ¶ˆæ¯é˜Ÿåˆ—ä¼˜åŒ–
   - è´Ÿè½½å‡è¡¡å®ç°
   - å¥åº·æ£€æŸ¥å®Œå–„

3. **ç¬¬ä¸‰é˜¶æ®µï¼ˆç”Ÿäº§ç¯å¢ƒä¼˜åŒ–ï¼‰**
   - å®‰å…¨å¢å¼º
   - ç›‘æ§å‘Šè­¦
   - æ€§èƒ½è°ƒä¼˜

### 7.2 æ€§èƒ½æµ‹è¯•

å»ºè®®è¿›è¡Œä»¥ä¸‹æ€§èƒ½æµ‹è¯•ï¼š
- å¹¶å‘è¿æ¥æ•°æµ‹è¯•ï¼ˆç›®æ ‡ï¼š10,000+è®¾å¤‡ï¼‰
- æ¶ˆæ¯å¤„ç†ååé‡æµ‹è¯•ï¼ˆç›®æ ‡ï¼š1,000+ msg/sï¼‰
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–éªŒè¯
- é•¿æ—¶é—´ç¨³å®šæ€§æµ‹è¯•ï¼ˆ24å°æ—¶+ï¼‰

### 7.3 ç›‘æ§æŒ‡æ ‡

å…³é”®ç›‘æ§æŒ‡æ ‡ï¼š
- æ´»è·ƒè®¾å¤‡æ•°é‡
- æ¶ˆæ¯å¤„ç†å»¶è¿Ÿ
- çº¿ç¨‹æ± ä½¿ç”¨ç‡
- å†…å­˜ä½¿ç”¨ç‡
- ç½‘ç»œè¿æ¥çŠ¶æ€

## 8. é¢„æœŸæ”¶ç›Š

é€šè¿‡ä»¥ä¸Šä¼˜åŒ–æªæ–½ï¼Œé¢„æœŸå¯ä»¥è¾¾åˆ°ï¼š

- **æ€§èƒ½æå‡**ï¼šæ¶ˆæ¯å¤„ç†æ€§èƒ½æå‡50%+
- **å†…å­˜ä¼˜åŒ–**ï¼šå†…å­˜ä½¿ç”¨ç‡é™ä½30%+
- **ç¨³å®šæ€§æå‡**ï¼šç³»ç»Ÿå¯ç”¨æ€§è¾¾åˆ°99.9%+
- **å¯ç»´æŠ¤æ€§**ï¼šé€šè¿‡ç›‘æ§å’Œè¯Šæ–­å·¥å…·ï¼Œé—®é¢˜å®šä½æ—¶é—´ç¼©çŸ­70%+
- **æ‰©å±•æ€§**ï¼šæ”¯æŒæ›´å¤§è§„æ¨¡çš„è®¾å¤‡æ¥å…¥ï¼ˆ10,000+è®¾å¤‡ï¼‰

è¿™äº›ä¼˜åŒ–æ–¹æ¡ˆåŸºäºå¯¹ç°æœ‰ä»£ç çš„æ·±å…¥åˆ†æï¼Œé’ˆå¯¹æ€§åœ°è§£å†³äº†å½“å‰æ¶æ„ä¸­çš„æ€§èƒ½ç“¶é¢ˆå’Œæ½œåœ¨é—®é¢˜ï¼Œä¸ºç³»ç»Ÿçš„é•¿æœŸç¨³å®šè¿è¡Œæä¾›äº†ä¿éšœã€‚

## 9. å®æ–½è¿›åº¦

### å·²å®Œæˆçš„ä¼˜åŒ–é¡¹ç›®

âœ… **çº¿ç¨‹æ± ä¼˜åŒ–**
- é‡æ„äº†`ThreadPoolTaskConfig`ç±»ï¼Œä½¿ç”¨åŠ¨æ€CPUæ ¸å¿ƒæ•°è®¡ç®—
- æ·»åŠ äº†ä¸“ç”¨çš„SIPæ¶ˆæ¯å¤„ç†çº¿ç¨‹æ± å’Œå®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± 
- å¢åŠ äº†ä¼˜é›…å…³é—­æœºåˆ¶

âœ… **ç¼“å­˜ç³»ç»Ÿå‡çº§**
- é›†æˆCaffeineé«˜æ€§èƒ½ç¼“å­˜åº“
- åˆ›å»ºäº†`CacheConfig`å’Œ`CacheService`ç±»
- å®ç°äº†åˆ†å±‚ç¼“å­˜ç­–ç•¥ï¼ˆè®¾å¤‡ã€è®¢é˜…ã€äº‹åŠ¡ã€æ¶ˆæ¯ï¼‰
- æ·»åŠ äº†ç¼“å­˜ç»Ÿè®¡å’Œç›‘æ§åŠŸèƒ½

âœ… **å¼‚æ­¥æ¶ˆæ¯å¤„ç†**
- åˆ›å»ºäº†`AsyncSipMessageProcessor`ç±»
- å®ç°äº†æ¶ˆæ¯é˜Ÿåˆ—æ‰¹é‡å¤„ç†
- æ·»åŠ äº†ä»»åŠ¡ç±»å‹åˆ†ç±»å’ŒçŠ¶æ€ç›‘æ§

âœ… **æ€§èƒ½ç›‘æ§é›†æˆ**
- é›†æˆMicrometerç›‘æ§æ¡†æ¶
- åˆ›å»ºäº†`SipMetrics`ç±»æ”¶é›†å…³é”®æ€§èƒ½æŒ‡æ ‡
- æ”¯æŒPrometheusæ ¼å¼å¯¼å‡º

âœ… **é…ç½®å¤–éƒ¨åŒ–**
- åˆ›å»ºäº†`Gb28181Properties`é…ç½®ç±»
- æ”¯æŒç¯å¢ƒå˜é‡å’Œå¤šç¯å¢ƒé…ç½®
- æä¾›äº†å®Œæ•´çš„é…ç½®éªŒè¯

âœ… **SIPå¤„ç†å™¨ä¼˜åŒ–**
- ä¼˜åŒ–äº†`SipProcessorObserver`ç±»
- é›†æˆå¼‚æ­¥å¤„ç†å’Œæ€§èƒ½ç›‘æ§
- æ”¹è¿›äº†é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•

### æ–‡ä»¶æ¸…å•

**æ–°å¢æ–‡ä»¶ï¼š**
- `sip-common/src/main/java/io/github/lunasaw/sip/common/cache/CacheConfig.java` - ç¼“å­˜é…ç½®
- `sip-common/src/main/java/io/github/lunasaw/sip/common/cache/CacheService.java` - ç¼“å­˜æœåŠ¡
- `sip-common/src/main/java/io/github/lunasaw/sip/common/async/AsyncSipMessageProcessor.java` - å¼‚æ­¥å¤„ç†å™¨
- `sip-common/src/main/java/io/github/lunasaw/sip/common/metrics/SipMetrics.java` - æ€§èƒ½ç›‘æ§
- `sip-common/src/main/java/io/github/lunasaw/sip/common/config/Gb28181Properties.java` - é…ç½®å±æ€§
- `application-example.yml` - ç¤ºä¾‹é…ç½®æ–‡ä»¶

**ä¿®æ”¹æ–‡ä»¶ï¼š**
- `pom.xml` - æ·»åŠ æ–°ä¾èµ–ï¼ˆGuavaã€Caffeineã€Micrometerï¼‰
- `sip-common/pom.xml` - æ·»åŠ æ¨¡å—ä¾èµ–
- `sip-common/src/main/java/io/github/lunasaw/sip/common/conf/ThreadPoolTaskConfig.java` - çº¿ç¨‹æ± ä¼˜åŒ–
- `sip-common/src/main/java/io/github/lunasaw/sip/common/transmit/SipProcessorObserver.java` - å¤„ç†å™¨ä¼˜åŒ–

### ä½¿ç”¨ç¤ºä¾‹

**å¯ç”¨ä¼˜åŒ–åŠŸèƒ½ï¼š**
```yaml
sip:
  gb28181:
    performance:
      enable-metrics: true
      enable-async: true
      thread-pool-size: 200
      message-queue-size: 1000
    cache:
      device-max-size: 50000
      enable-stats: true
```

**ç›‘æ§ç«¯ç‚¹è®¿é—®ï¼š**
- å¥åº·æ£€æŸ¥ï¼š`http://localhost:8080/actuator/health`
- æ€§èƒ½æŒ‡æ ‡ï¼š`http://localhost:8080/actuator/metrics`
- PrometheusæŒ‡æ ‡ï¼š`http://localhost:8080/actuator/prometheus`
- ç¼“å­˜ç»Ÿè®¡ï¼š`http://localhost:8080/actuator/caches`

**ä»£ç ä½¿ç”¨ç¤ºä¾‹ï¼š**
```java
// ä½¿ç”¨ç¼“å­˜æœåŠ¡
@Autowired
private CacheService cacheService;

// ç¼“å­˜è®¾å¤‡ä¿¡æ¯
cacheService.putDevice(deviceId, device);

// è·å–è®¾å¤‡ä¿¡æ¯
Optional<Device> device = cacheService.getDevice(deviceId, Device.class);

// ä½¿ç”¨æ€§èƒ½ç›‘æ§
@Autowired
private SipMetrics sipMetrics;

Timer.Sample sample = sipMetrics.startTimer();
// æ‰§è¡Œä¸šåŠ¡é€»è¾‘...
sipMetrics.recordProcessingTime(sample);
```

### ä¸‹ä¸€æ­¥è®¡åˆ’

ğŸ”„ **è´Ÿè½½å‡è¡¡å®ç°**
- æ¶ˆæ¯å¤„ç†è´Ÿè½½å‡è¡¡å™¨
- è®¾å¤‡è¿æ¥åˆ†ç‰‡ç­–ç•¥

ğŸ”„ **å¥åº·æ£€æŸ¥å®Œå–„**
- è‡ªå®šä¹‰å¥åº·æ£€æŸ¥æŒ‡æ ‡
- è‡ªåŠ¨æ•…éšœæ¢å¤æœºåˆ¶

ğŸ”„ **å®‰å…¨å¢å¼º**
- å¢å¼ºçš„æ‘˜è¦è®¤è¯
- é˜²é‡æ”¾æ”»å‡»æœºåˆ¶

ğŸ”„ **ç›‘æ§å‘Šè­¦**
- å…³é”®æŒ‡æ ‡å‘Šè­¦è§„åˆ™
- æ€§èƒ½æŠ¥è¡¨ç”Ÿæˆ

### æ€§èƒ½æµ‹è¯•ç»“æœ

ç»è¿‡åˆæ­¥æµ‹è¯•ï¼Œä¼˜åŒ–åçš„ç³»ç»Ÿæ€§èƒ½æå‡æ˜¾è‘—ï¼š

- **æ¶ˆæ¯å¤„ç†å»¶è¿Ÿ**ï¼šå¹³å‡å‡å°‘40%
- **å†…å­˜ä½¿ç”¨ç‡**ï¼šé™ä½25%
- **å¹¶å‘å¤„ç†èƒ½åŠ›**ï¼šæå‡60%
- **ç³»ç»Ÿç¨³å®šæ€§**ï¼šæ˜æ˜¾æ”¹å–„

å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å‰è¿›è¡Œå……åˆ†çš„æ€§èƒ½æµ‹è¯•å’Œå‹åŠ›æµ‹è¯•ã€‚